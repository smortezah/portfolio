"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[6231],{92018:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var t=i(85893),a=i(11151);const s={title:"Dealing with Missing Data",description:"Learn how to handle missing data in Python",tags:["Python","Data Science","Missing Data","Machine Learning","Imputation"]},r="Dealing with Missing Data Like a Pro",o={id:"eda/missing-data",title:"Dealing with Missing Data",description:"Learn how to handle missing data in Python",source:"@site/docs/eda/missing-data.md",sourceDirName:"eda",slug:"/eda/missing-data",permalink:"/portfolio/docs/eda/missing-data",draft:!1,unlisted:!1,tags:[{label:"Python",permalink:"/portfolio/docs/tags/python"},{label:"Data Science",permalink:"/portfolio/docs/tags/data-science"},{label:"Missing Data",permalink:"/portfolio/docs/tags/missing-data"},{label:"Machine Learning",permalink:"/portfolio/docs/tags/machine-learning"},{label:"Imputation",permalink:"/portfolio/docs/tags/imputation"}],version:"current",frontMatter:{title:"Dealing with Missing Data",description:"Learn how to handle missing data in Python",tags:["Python","Data Science","Missing Data","Machine Learning","Imputation"]},sidebar:"tutorialSidebar",previous:{title:"Dirty Data",permalink:"/portfolio/docs/eda/dirty-data"},next:{title:"Pivot Tables with pandas",permalink:"/portfolio/docs/eda/pivot-pandas"}},d={},l=[{value:"Understanding the Missing Data Landscape",id:"understanding-the-missing-data-landscape",level:2},{value:"Detecting Missing Data",id:"detecting-missing-data",level:2},{value:"Strategies for Handling Missing Data",id:"strategies-for-handling-missing-data",level:2},{value:"Imputation Techniques",id:"imputation-techniques",level:3},{value:"Forward and Backward Fill",id:"forward-and-backward-fill",level:3},{value:"Predictive Imputation",id:"predictive-imputation",level:3},{value:"K-Nearest Neighbors (KNN)",id:"k-nearest-neighbors-knn",level:3},{value:"Verifying Imputations",id:"verifying-imputations",level:2},{value:"Check for Remaining Missing Values",id:"check-for-remaining-missing-values",level:3},{value:"Compare Distributions",id:"compare-distributions",level:3},{value:"Domain-Specific Imputation",id:"domain-specific-imputation",level:2},{value:"Time-Series Imputation",id:"time-series-imputation",level:3},{value:"Categorical Data Imputation",id:"categorical-data-imputation",level:3},{value:"Wrapping up",id:"wrapping-up",level:2}];function c(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.h1,{id:"dealing-with-missing-data-like-a-pro",children:"Dealing with Missing Data Like a Pro"}),"\n",(0,t.jsx)(e.p,{children:"Welcome, fellow data enthusiasts and Python aficionados! Today, we embark on a thrilling journey to tackle one of the most common challenges in data science \u2014 missing data! Ah, those pesky gaps in our datasets that can ruin our models and give us headaches. But fear not! With Python as our trusty companion, we shall equip ourselves with the skills to handle missing data. So, fasten your seatbelts and let\u2019s dive in!"}),"\n",(0,t.jsx)(e.h2,{id:"understanding-the-missing-data-landscape",children:"Understanding the Missing Data Landscape"}),"\n",(0,t.jsx)(e.p,{children:"Before we don our data superhero capes, let\u2019s take a moment to understand the types of missing data we might encounter in our datasets:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Missing Completely at Random (MCAR):"})," Imagine a mischievous data gremlin randomly removing entries from our dataset while we\u2019re not looking. Sneaky, right? Well, these missing values are said to be MCAR, where their absence is unrelated to any variables in our dataset. No patterns, no worries!"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Missing at Random (MAR):"})," This type of missing data shows a bit of cunning. Here, the probability of data being missing depends on other observed variables. As if it\u2019s saying, \u201cHey, if you already know X and Y, I\u2019ll decide whether to hide.\u201d"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Missing Not at Random (MNAR):"})," These missing values are neither random nor related to the observed variables. They might hide for specific reasons unknown to us, and they\u2019re quite adept at keeping secrets."]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"detecting-missing-data",children:"Detecting Missing Data"}),"\n",(0,t.jsx)(e.p,{children:"Now that we\u2019re familiar with the missing data breeds, it\u2019s time to put on our detective hats and find those gaps in our dataset. Our Python magnifying glass and trusty pandas library will come to the rescue:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'import pandas as pd\n\n# Load your dataset\ndata = pd.DataFrame(\n    {\n        "A": [1, 2, None, 4],\n        "B": [5, None, 7, None],\n        "C": [None, 9, None, 11],\n        "D": [12, 8, 14, 15],\n    }\n)\n\n# Print the dataset\nprint("Original dataset:")\nprint(data)\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original dataset:\n     A    B     C   D\n0  1.0  5.0   NaN  12\n1  2.0  NaN   9.0   8\n2  NaN  7.0   NaN  14\n3  4.0  NaN  11.0  15\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'# Check for missing values in the entire dataset\nprint("\\nMissing values in the entire dataset:")\nprint(data.isnull().sum())\n\n# Identify columns with missing values\nprint("\\nColumns with missing values:")\nprint(data.columns[data.isnull().any()].tolist())\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Missing values in the entire dataset:\nA    1\nB    2\nC    2\nD    0\ndtype: int64\n\nColumns with missing values:\n['A', 'B', 'C']\n"})}),"\n",(0,t.jsxs)(e.p,{children:["The ",(0,t.jsx)(e.code,{children:"isnull().sum()"})," command gives us the number of missing values in each column, while ",(0,t.jsx)(e.code,{children:"data.columns[data.isnull().any()]"})," reveals the columns with missing data. Now we know where our data gremlins have been up to their mischief!"]}),"\n",(0,t.jsx)(e.h2,{id:"strategies-for-handling-missing-data",children:"Strategies for Handling Missing Data"}),"\n",(0,t.jsx)(e.h3,{id:"imputation-techniques",children:"Imputation Techniques"}),"\n",(0,t.jsx)(e.p,{children:"Missing data can leave unsightly holes in our analysis, but fear not, for we shall artfully fill in these gaps with imputation techniques. One popular method is mean imputation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'# Print the original column A\nprint("\\nOriginal column A:")\nprint(data["A"])\n\n# Impute missing values with the column A\'s mean\ndata_imputed = data["A"].fillna(data["A"].mean())\n\n# Print the imputed column A\nprint("\\nImputed column A:")\nprint(data_imputed)\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original column A:\n0    1.0\n1    2.0\n2    NaN\n3    4.0\nName: A, dtype: float64\n\nImputed column A:\n0    1.000000\n1    2.000000\n2    2.333333\n3    4.000000\nName: A, dtype: float64\n"})}),"\n",(0,t.jsx)(e.h3,{id:"forward-and-backward-fill",children:"Forward and Backward Fill"}),"\n",(0,t.jsx)(e.p,{children:"For sequential data, such as time-series, we can employ forward-fill or backward-fill techniques to propagate the last observed value:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'# Print the original column B\nprint("\\nOriginal column B:")\nprint(data["B"])\n\n# Forward-fill missing values in column B\ndata_imputed = data["B"].fillna(method="ffill")\n\n# Print the forward-filled column B\nprint("\\nForward-filled column B:")\nprint(data_imputed)\n\n# Backward-fill missing values\ndata_imputed = data["B"].fillna(method="bfill")\n\n# Print the backward-filled column B\nprint("\\nBackward-filled column B:")\nprint(data_imputed)\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Original column B:\n0    5.0\n1    NaN\n2    7.0\n3    NaN\nName: B, dtype: float64\n\nForward-filled column B:\n0    5.0\n1    5.0\n2    7.0\n3    7.0\nName: B, dtype: float64\n\nBackward-filled column B:\n0    5.0\n1    7.0\n2    7.0\n3    NaN\nName: B, dtype: float64\n"})}),"\n",(0,t.jsx)(e.h3,{id:"predictive-imputation",children:"Predictive Imputation"}),"\n",(0,t.jsx)(e.p,{children:"For a touch of magic, we can use machine learning models to predict missing values based on other features:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'from sklearn.ensemble import RandomForestRegressor\n\n\ndef impute_with_random_forest(df, target_column):\n    # Split data into two sets: with and without missing values in the\n    # target column\n    known = df[df[target_column].notnull()]\n    unknown = df[df[target_column].isnull()]\n\n    # Create the Random Forest model\n    model = RandomForestRegressor()\n\n    # Train the model on known data to predict missing values\n    X = known.drop(columns=[target_column])\n    y = known[target_column]\n    model.fit(X, y)\n\n    # Predict missing values\n    predicted_values = model.predict(unknown.drop(columns=[target_column]))\n\n    # Assign predicted values to missing entries\n    df.loc[df[target_column].isnull(), target_column] = predicted_values\n\n\n# Impute missing values of all columns except C\ndata_imputed = data.copy()\ndata_imputed[["A", "B"]] = data_imputed[["A", "B"]].fillna(\n    data_imputed[["A", "B"]].mean()\n)\n\n# Print the dataset before imputing column C\nprint("Before imputing column C:")\nprint(data_imputed)\n\n# Impute the column C\nimpute_with_random_forest(data_imputed, "C")\n\n# Print the dataset after imputing column C\nprint("\\nAfter imputing column C:")\nprint(data_imputed)\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Before imputing column C:\n          A    B     C   D\n0  1.000000  5.0   NaN  12\n1  2.000000  6.0   9.0   8\n2  2.333333  7.0   NaN  14\n3  4.000000  6.0  11.0  15\n\nAfter imputing column C:\n          A    B      C   D\n0  1.000000  5.0   9.92  12\n1  2.000000  6.0   9.00   8\n2  2.333333  7.0   9.92  14\n3  4.000000  6.0  11.00  15\n"})}),"\n",(0,t.jsx)(e.h3,{id:"k-nearest-neighbors-knn",children:"K-Nearest Neighbors (KNN)"}),"\n",(0,t.jsx)(e.p,{children:"Let\u2019s embrace the spirit of camaraderie and let our friendly neighbors help us fill in the missing values:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'from sklearn.impute import KNNImputer\n\n# Create KNN imputer\nknn_imputer = KNNImputer(n_neighbors=2)\n\n# Perform imputation on all columns with missing values\narray_imputed = knn_imputer.fit_transform(data)\ndata_imputed = pd.DataFrame(array_imputed, columns=data.columns)\n\n# Print the original dataset\nprint("Before imputation:")\nprint(data)\n\n# Print the imputed dataset\nprint("\\nAfter imputation:")\nprint(data_imputed)\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Before imputation:\n     A    B     C   D\n0  1.0  5.0   NaN  12\n1  2.0  NaN   9.0   8\n2  NaN  7.0   NaN  14\n3  4.0  NaN  11.0  15\n\nAfter imputation:\n     A    B     C     D\n0  1.0  5.0  10.0  12.0\n1  2.0  6.0   9.0   8.0\n2  2.5  7.0  10.0  14.0\n3  4.0  6.0  11.0  15.0\n"})}),"\n",(0,t.jsx)(e.h2,{id:"verifying-imputations",children:"Verifying Imputations"}),"\n",(0,t.jsx)(e.p,{children:"Now that we\u2019ve sprinkled Python magic and conquered missing data, it\u2019s time to ensure our imputations are solid:"}),"\n",(0,t.jsx)(e.h3,{id:"check-for-remaining-missing-values",children:"Check for Remaining Missing Values"}),"\n",(0,t.jsx)(e.p,{children:"Let\u2019s verify if our imputation methods left any missing values lurking:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:"# Verify if any missing values remain\nprint(data_imputed.isnull().sum())\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"A    0\nB    0\nC    0\nD    0\ndtype: int64\n"})}),"\n",(0,t.jsx)(e.h3,{id:"compare-distributions",children:"Compare Distributions"}),"\n",(0,t.jsx)(e.p,{children:"For the imputed columns, compare the original and imputed distributions to ensure they\u2019re not drastically altered:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'# Visualize the distribution of the original and imputed data\ndata.plot(\n    kind="density", title="Original data", ylim=(0, 1), figsize=(4, 2)\n)\n\ndata_imputed.plot(\n    kind="density", title="Imputed data", ylim=(0, 1), figsize=(4, 2)\n);\n'})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:i(7866).Z+"",width:"381",height:"220"})}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{src:i(70041).Z+"",width:"381",height:"220"})}),"\n",(0,t.jsx)(e.h2,{id:"domain-specific-imputation",children:"Domain-Specific Imputation"}),"\n",(0,t.jsx)(e.h3,{id:"time-series-imputation",children:"Time-Series Imputation"}),"\n",(0,t.jsx)(e.p,{children:"For time-series data, we\u2019ll need a specialized approach. Enter interpolation:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'# Print the dataset before interpolation\nprint("Before interpolation:")\nprint(data)\n\n# Print the dataset after interpolation\nprint("\\nAfter interpolation:")\nprint(data.interpolate())\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Before interpolation:\n     A    B     C   D\n0  1.0  5.0   NaN  12\n1  2.0  NaN   9.0   8\n2  NaN  7.0   NaN  14\n3  4.0  NaN  11.0  15\n\nAfter interpolation:\n     A    B     C   D\n0  1.0  5.0   NaN  12\n1  2.0  6.0   9.0   8\n2  3.0  7.0  10.0  14\n3  4.0  7.0  11.0  15\n"})}),"\n",(0,t.jsx)(e.h3,{id:"categorical-data-imputation",children:"Categorical Data Imputation"}),"\n",(0,t.jsx)(e.p,{children:"When dealing with categorical data, mode imputation comes to our rescue:"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",metastring:'title="Python"',children:'# Dataset\ndata_cat = pd.Series(["a", "b", None, "d"] * 2 + ["b"])\n\n# Print the dataset before imputation\nprint("Before imputation:")\nprint(data_cat)\n\n# Find the most frequent category\nmost_frequent = data_cat.mode()[0]\nprint("\\nMost frequent category:", most_frequent)\n\n# Replace missing values with the most frequent category\ndata_cat.fillna(most_frequent, inplace=True)\n\n# Print the dataset after imputation\nprint("\\nAfter imputation:")\nprint(data_cat)\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Before imputation:\n0       a\n1       b\n2    None\n3       d\n4       a\n5       b\n6    None\n7       d\n8       b\ndtype: object\n\nMost frequent category: b\n\nAfter imputation:\n0    a\n1    b\n2    b\n3    d\n4    a\n5    b\n6    b\n7    d\n8    b\ndtype: object\n"})}),"\n",(0,t.jsx)(e.h2,{id:"wrapping-up",children:"Wrapping up"}),"\n",(0,t.jsx)(e.p,{children:"Congratulations, data explorers! You\u2019ve learned the secrets of handling missing data like a seasoned data scientist. Remember, handling missing data is an essential skill in the data scientist\u2019s toolkit, and with Python by your side, you\u2019re well-equipped to conquer any missing value challenges that come your way."}),"\n",(0,t.jsx)(e.p,{children:"Stay curious, keep coding, and let your data-driven dreams soar high!"}),"\n",(0,t.jsx)(e.p,{children:"Happy Python-ing! \ud83d\udc0d\u2728"})]})}function m(n={}){const{wrapper:e}={...(0,a.a)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(c,{...n})}):c(n)}},70041:(n,e,i)=>{i.d(e,{Z:()=>t});const t=i.p+"assets/images/missing-imputed-c38c852bdd9daf5a71c93ce2846a811a.png"},7866:(n,e,i)=>{i.d(e,{Z:()=>t});const t=i.p+"assets/images/missing-originial-28bdab55056bd9be1f0050ac21344959.png"},11151:(n,e,i)=>{i.d(e,{Z:()=>o,a:()=>r});var t=i(67294);const a={},s=t.createContext(a);function r(n){const e=t.useContext(s);return t.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:r(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);